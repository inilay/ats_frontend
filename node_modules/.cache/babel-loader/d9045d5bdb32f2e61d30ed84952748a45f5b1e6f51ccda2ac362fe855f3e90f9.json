{"ast":null,"code":"import { cloneNode } from './clone-node';\nimport { embedImages } from './embed-images';\nimport { applyStyle } from './apply-style';\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts';\nimport { getImageSize, getPixelRatio, createImage, canvasToBlob, nodeToDataURL, checkCanvasDimensions } from './util';\nexport async function toSvg(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    width,\n    height\n  } = getImageSize(node, options);\n  const clonedNode = await cloneNode(node, options, true);\n  await embedWebFonts(clonedNode, options);\n  await embedImages(clonedNode, options);\n  applyStyle(clonedNode, options);\n  const datauri = await nodeToDataURL(clonedNode, width, height);\n  return datauri;\n}\nexport async function toCanvas(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    width,\n    height\n  } = getImageSize(node, options);\n  const svg = await toSvg(node, options);\n  const img = await createImage(svg);\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  const ratio = options.pixelRatio || getPixelRatio();\n  const canvasWidth = options.canvasWidth || width;\n  const canvasHeight = options.canvasHeight || height;\n  canvas.width = canvasWidth * ratio;\n  canvas.height = canvasHeight * ratio;\n  if (!options.skipAutoScale) {\n    checkCanvasDimensions(canvas);\n  }\n  canvas.style.width = `${canvasWidth}`;\n  canvas.style.height = `${canvasHeight}`;\n  if (options.backgroundColor) {\n    context.fillStyle = options.backgroundColor;\n    context.fillRect(0, 0, canvas.width, canvas.height);\n  }\n  context.drawImage(img, 0, 0, canvas.width, canvas.height);\n  return canvas;\n}\nexport async function toPixelData(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    width,\n    height\n  } = getImageSize(node, options);\n  const canvas = await toCanvas(node, options);\n  const ctx = canvas.getContext('2d');\n  return ctx.getImageData(0, 0, width, height).data;\n}\nexport async function toPng(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const canvas = await toCanvas(node, options);\n  return canvas.toDataURL();\n}\nexport async function toJpeg(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const canvas = await toCanvas(node, options);\n  return canvas.toDataURL('image/jpeg', options.quality || 1);\n}\nexport async function toBlob(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const canvas = await toCanvas(node, options);\n  const blob = await canvasToBlob(canvas);\n  return blob;\n}\nexport async function getFontEmbedCSS(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return getWebFontCSS(node, options);\n}","map":{"version":3,"mappings":"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","names":["cloneNode","embedImages","applyStyle","embedWebFonts","getWebFontCSS","getImageSize","getPixelRatio","createImage","canvasToBlob","nodeToDataURL","checkCanvasDimensions","toSvg","node","options","width","height","clonedNode","datauri","toCanvas","svg","img","canvas","document","createElement","context","getContext","ratio","pixelRatio","canvasWidth","canvasHeight","skipAutoScale","style","backgroundColor","fillStyle","fillRect","drawImage","toPixelData","ctx","getImageData","data","toPng","toDataURL","toJpeg","quality","toBlob","blob","getFontEmbedCSS"],"sources":["/home/at/vercel_frontend/ATS/frontend/node_modules/html-to-image/src/index.ts"],"sourcesContent":["import { Options } from './types'\nimport { cloneNode } from './clone-node'\nimport { embedImages } from './embed-images'\nimport { applyStyle } from './apply-style'\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts'\nimport {\n  getImageSize,\n  getPixelRatio,\n  createImage,\n  canvasToBlob,\n  nodeToDataURL,\n  checkCanvasDimensions,\n} from './util'\n\nexport async function toSvg<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const { width, height } = getImageSize(node, options)\n  const clonedNode = (await cloneNode(node, options, true)) as HTMLElement\n  await embedWebFonts(clonedNode, options)\n  await embedImages(clonedNode, options)\n  applyStyle(clonedNode, options)\n  const datauri = await nodeToDataURL(clonedNode, width, height)\n  return datauri\n}\n\nexport async function toCanvas<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<HTMLCanvasElement> {\n  const { width, height } = getImageSize(node, options)\n  const svg = await toSvg(node, options)\n  const img = await createImage(svg)\n\n  const canvas = document.createElement('canvas')\n  const context = canvas.getContext('2d')!\n  const ratio = options.pixelRatio || getPixelRatio()\n  const canvasWidth = options.canvasWidth || width\n  const canvasHeight = options.canvasHeight || height\n\n  canvas.width = canvasWidth * ratio\n  canvas.height = canvasHeight * ratio\n\n  if (!options.skipAutoScale) {\n    checkCanvasDimensions(canvas)\n  }\n  canvas.style.width = `${canvasWidth}`\n  canvas.style.height = `${canvasHeight}`\n\n  if (options.backgroundColor) {\n    context.fillStyle = options.backgroundColor\n    context.fillRect(0, 0, canvas.width, canvas.height)\n  }\n\n  context.drawImage(img, 0, 0, canvas.width, canvas.height)\n\n  return canvas\n}\n\nexport async function toPixelData<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<Uint8ClampedArray> {\n  const { width, height } = getImageSize(node, options)\n  const canvas = await toCanvas(node, options)\n  const ctx = canvas.getContext('2d')!\n  return ctx.getImageData(0, 0, width, height).data\n}\n\nexport async function toPng<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const canvas = await toCanvas(node, options)\n  return canvas.toDataURL()\n}\n\nexport async function toJpeg<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const canvas = await toCanvas(node, options)\n  return canvas.toDataURL('image/jpeg', options.quality || 1)\n}\n\nexport async function toBlob<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<Blob | null> {\n  const canvas = await toCanvas(node, options)\n  const blob = await canvasToBlob(canvas)\n  return blob\n}\n\nexport async function getFontEmbedCSS<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  return getWebFontCSS(node, options)\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}