{"ast":null,"code":"import { embedResources } from './embed-resources';\nimport { toArray, isInstanceOfElement } from './util';\nimport { isDataUrl, resourceToDataURL } from './dataurl';\nimport { getMimeType } from './mimes';\nasync function embedProp(propName, node, options) {\n  var _a;\n  const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);\n  if (propValue) {\n    const cssString = await embedResources(propValue, null, options);\n    node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));\n    return true;\n  }\n  return false;\n}\nasync function embedBackground(clonedNode, options) {\n  if (!(await embedProp('background', clonedNode, options))) {\n    await embedProp('background-image', clonedNode, options);\n  }\n  if (!(await embedProp('mask', clonedNode, options))) {\n    await embedProp('mask-image', clonedNode, options);\n  }\n}\nasync function embedImageNode(clonedNode, options) {\n  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);\n  if (!(isImageElement && !isDataUrl(clonedNode.src)) && !(isInstanceOfElement(clonedNode, SVGImageElement) && !isDataUrl(clonedNode.href.baseVal))) {\n    return;\n  }\n  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;\n  const dataURL = await resourceToDataURL(url, getMimeType(url), options);\n  await new Promise((resolve, reject) => {\n    clonedNode.onload = resolve;\n    clonedNode.onerror = reject;\n    const image = clonedNode;\n    if (image.decode) {\n      image.decode = resolve;\n    }\n    if (image.loading === 'lazy') {\n      image.loading = 'eager';\n    }\n    if (isImageElement) {\n      clonedNode.srcset = '';\n      clonedNode.src = dataURL;\n    } else {\n      clonedNode.href.baseVal = dataURL;\n    }\n  });\n}\nasync function embedChildren(clonedNode, options) {\n  const children = toArray(clonedNode.childNodes);\n  const deferreds = children.map(child => embedImages(child, options));\n  await Promise.all(deferreds).then(() => clonedNode);\n}\nexport async function embedImages(clonedNode, options) {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    await embedBackground(clonedNode, options);\n    await embedImageNode(clonedNode, options);\n    await embedChildren(clonedNode, options);\n  }\n}","map":{"version":3,"mappings":"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","names":["embedResources","toArray","isInstanceOfElement","isDataUrl","resourceToDataURL","getMimeType","embedProp","propName","node","options","propValue","style","getPropertyValue","cssString","setProperty","getPropertyPriority","embedBackground","clonedNode","embedImageNode","isImageElement","HTMLImageElement","src","SVGImageElement","href","baseVal","url","dataURL","Promise","resolve","reject","onload","onerror","image","decode","loading","srcset","embedChildren","children","childNodes","deferreds","map","child","embedImages","all","then","Element"],"sources":["/home/at/vercel_frontend/ATS/frontend/node_modules/html-to-image/src/embed-images.ts"],"sourcesContent":["import { Options } from './types'\nimport { embedResources } from './embed-resources'\nimport { toArray, isInstanceOfElement } from './util'\nimport { isDataUrl, resourceToDataURL } from './dataurl'\nimport { getMimeType } from './mimes'\n\nasync function embedProp(\n  propName: string,\n  node: HTMLElement,\n  options: Options,\n) {\n  const propValue = node.style?.getPropertyValue(propName)\n  if (propValue) {\n    const cssString = await embedResources(propValue, null, options)\n    node.style.setProperty(\n      propName,\n      cssString,\n      node.style.getPropertyPriority(propName),\n    )\n    return true\n  }\n  return false\n}\n\nasync function embedBackground<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (!(await embedProp('background', clonedNode, options))) {\n    await embedProp('background-image', clonedNode, options)\n  }\n  if (!(await embedProp('mask', clonedNode, options))) {\n    await embedProp('mask-image', clonedNode, options)\n  }\n}\n\nasync function embedImageNode<T extends HTMLElement | SVGImageElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement)\n\n  if (\n    !(isImageElement && !isDataUrl(clonedNode.src)) &&\n    !(\n      isInstanceOfElement(clonedNode, SVGImageElement) &&\n      !isDataUrl(clonedNode.href.baseVal)\n    )\n  ) {\n    return\n  }\n\n  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal\n\n  const dataURL = await resourceToDataURL(url, getMimeType(url), options)\n  await new Promise((resolve, reject) => {\n    clonedNode.onload = resolve\n    clonedNode.onerror = reject\n\n    const image = clonedNode as HTMLImageElement\n    if (image.decode) {\n      image.decode = resolve as any\n    }\n\n    if (image.loading === 'lazy') {\n      image.loading = 'eager'\n    }\n\n    if (isImageElement) {\n      clonedNode.srcset = ''\n      clonedNode.src = dataURL\n    } else {\n      clonedNode.href.baseVal = dataURL\n    }\n  })\n}\n\nasync function embedChildren<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const children = toArray<HTMLElement>(clonedNode.childNodes)\n  const deferreds = children.map((child) => embedImages(child, options))\n  await Promise.all(deferreds).then(() => clonedNode)\n}\n\nexport async function embedImages<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    await embedBackground(clonedNode, options)\n    await embedImageNode(clonedNode, options)\n    await embedChildren(clonedNode, options)\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}